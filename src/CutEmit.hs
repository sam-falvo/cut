{-
  CutEmit.hs
  CUT Release 2.6-Experimental
  Copyright (c) 2007 Samuel A. Falvo II, William D. Tanksley Jr.
  See LICENSE for details.

  2007-Mar-10 Samuel A. Falvo II

  The emitter is used to generate C source output corresponding to the
  discovered unit tests.
-}

module CutEmit where

import qualified CutLexer              as L
import qualified CutParser             as P
import qualified Data.ByteString.Char8 as S
import IO

-- Clips are used to express chunks of text.  They can be small.  They
-- can be big.  Clips can even be composed of other clips.  Using clips like
-- this, we avoid the runtime and, hopefully, memory overhead of
-- concatenation on large source files.

data Clip = Chunk S.ByteString | Chunks [Clip]

-- The test runner consists of the relavent includes, external function
-- declarations, and the main() function, which is responsible for
-- actually invoking the tests in the proper order.

testRunner :: [P.CutParsed] -> Clip
testRunner ns = Chunks $ headers:(externs ns):(mainFunction ns):[]

-- The test runner's header file is usually the default location of
-- <cut/3/cut.h>.  However, this can be altered if desired via the
-- -i command-line option.

headers :: Clip
headers = Chunk $ S.pack $
            "/* Automatically generated by cutgen 2.6/X. */\n" ++
            "#include <cut/3/cut.h>\n"

-- All test functions are external to the cutgen-produced runner, since
-- they all must exist in other files.

externs :: [P.CutParsed] -> Clip
externs ns = Chunks $ map externalized $ flattened ns
  where
    externalized n  = extern $ P.idOf n
    extern s        = Chunks $ (Chunk $ S.pack "extern void "):Chunk s:[Chunk $ S.pack "();\n"]

-- Flattening a P.CutParsed tree is necessary to get a convenient listing of
-- all referenced functions in the program.

flattened :: [P.CutParsed] -> [P.CutParsed]
flattened []                    = []
flattened (n:ns)                = (flatten n)++(flattened ns)

flatten :: P.CutParsed -> [P.CutParsed]
flatten t@(P.Test _)              = [t]
flatten t@(P.Takedown _)          = [t]
flatten b@(P.Bringup _ children)  = [b]++(flattened children)
flatten s@(P.Setup _ children)    = [s]++(flattened children)

-- The main() function itself comprises of the type signature,
-- some basic startup code, and the actual function body proper.

mainFunction :: [P.CutParsed] -> Clip
mainFunction ns = Chunks $ startMain:initialization:body ns:endMain:[]
  where
    startMain = Chunk $ S.pack "int main(int argc, char *argv[]) {\n"
    endMain   = Chunk $ S.pack "return 0;\n}\n"

-- P.Test runner initialization is done using the __cut_init() function.

initialization = Chunk $ S.pack "__cut_init(-1);\n"

-- The body of the main function can now properly sequence all the tests.
-- Note that CUT versions 1.0-2.4 only supported P.Bringup-style contexts.
-- P.Setups didn't exist until 2.6X.  For this reason, CUT's default
-- behavior is to assume tests are running inside a (null) P.Bringup context.

body :: [P.CutParsed] -> Clip
body = bringupBody

bringupBody :: [P.CutParsed] -> Clip
bringupBody [] = Chunk $ S.pack ""
bringupBody (node:nodes) =
  case node of
    (P.Test name) ->
      Chunks $ (call node):(bringupBody nodes):[]
    (P.Bringup name children) ->
      Chunks $ (call node):(bringupBody children):(bringupBody nodes):[]
    (P.Setup name children) ->
      Chunks $ (setupBody name children):bringupBody nodes:[]
    (P.Takedown name) ->
      call node

-- When a P.Setup context is encountered, we need to process the children
-- quite differently; instead of a whole body of tests being wrapped in a
-- single bringup or takedown, *each test* is wrapped individually.
-- Because we continuously need to know the name of the context, we need the
-- extra ctx parameter.

setupBody :: S.ByteString -> [P.CutParsed] -> Clip
setupBody _ [] = Chunk $ S.pack ""
setupBody ctx (node:nodes) =
  case node of
    (P.Test name) ->
      Chunks $ (wrap ctx $ call node):(setupBody ctx nodes):[]
    (P.Bringup name children) ->
      Chunks $ (wrap ctx $ bringupSeq children):(setupBody ctx nodes):[]
    (P.Setup name children) ->
      Chunks $ (wrap ctx $ setupBody name children):(setupBody ctx nodes):[]
    (P.Takedown name) ->
      Chunk $ S.pack ""

  where
    bringupSeq c = Chunks $ (call node):(bringupBody c):[]

    wrap ctx s   = Chunks $ (setup ctx):s:(takedown ctx):[]
    setup ctx    = invoke $ L.setupIdFor ctx
    takedown ctx = invoke $ L.takedownIdFor ctx
    invoke s     = Chunks $ (Chunk s):(Chunk $ S.pack $ "();\n"):[]

-- We have need of invoking the services of the user-supplied code
-- corresponding to the node.  Fortunately, CutParse.hs knows the full name
-- of this node.

call cn = Chunks $ (Chunk $ P.idOf cn):[Chunk $ S.pack "();\n"]

